SQL DB ...

En SQL (Structured Query Language), los tipos de datos definen el tipo de valor que se puede almacenar en una columna de una tabla. Estos tipos de datos son fundamentales para asegurar la integridad y la correcta manipulación de la información. A continuación se describen los principales tipos de datos en SQL, que pueden variar ligeramente según el sistema de gestión de bases de datos (SGBD) utilizado (como MySQL, PostgreSQL, SQL Server, Oracle, etc.)

Tipos de datos numéricos
Enteros
INT o INTEGER: Número entero de tamaño estándar.
SMALLINT: Número entero de menor rango.
TINYINT: Número entero de rango muy pequeño (comúnmente en MySQL).
BIGINT: Número entero de mayor rango.
Decimales y de punto flotante
FLOAT: Número de punto flotante de precisión simple.
DOUBLE o DOUBLE PRECISION: Número de punto flotante de precisión doble.
DECIMAL o NUMERIC: Número exacto con un número fijo de dígitos decimales. El decimal lo vamos a especificar con la palabra reservada DECIMAL (10,2) el segundo valor va a determinar cual es la precisión fija de almacenamiento que le estas dando a ese decimal
Tipos de datos de caracteres (texto)
Cadenas de caracteres
CHAR(n): Cadena de longitud fija. Si asignas 10 espacios CHAR(10) para guardar un hola, este te va a ocupar esos 10 espacios.
VARCHAR(n): Cadena de longitud variable, a nivel de procesamiento estos 2 aunque en sintaxis se escriben igual funcionan diferente en procesamiento, si asignas 10 espacios para un hola, solamente ocupara esos 4 espacios del hola
Textos largos
TEXT: Cadena de longitud variable de gran tamaño (comúnmente en MySQL).
CLOB (Character Large Object): Similar a TEXT en otros SGBD.
Tipos de datos de fecha y hora
DATE: Fecha (año, mes, día).
TIME: Hora (hora, minuto, segundo).
DATETIME: Combinación de fecha y hora.
TIMESTAMP: Fecha y hora, generalmente con capacidad de zona horaria.
YEAR: Año (comúnmente en MySQL).
Tipos de datos booleanos
BOOLEAN: Valor verdadero o falso (no soportado de forma nativa en algunos SGBD, se puede simular con TINYINT).
Tipos de datos binarios
BINARY: Datos binarios de longitud fija.
VARBINARY: Datos binarios de longitud variable.
BLOB (Binary Large Object): Datos binarios de gran tamaño.
Otros tipos de datos
ENUM: Enumeración de valores predefinidos (comúnmente en MySQL).
SET: Conjunto de valores predefinidos (comúnmente en MySQL).
XML: Datos en formato XML.
JSON: Datos en formato JSON (soportado en PostgreSQL, MySQL y otros).
UUID: Identificador único universal.
Ejemplos en SQL
Aquí hay algunos ejemplos de cómo se definen columnas con diferentes tipos de datos en una tabla SQL:

CREATE TABLE ejemplo ( id INT PRIMARY KEY, nombre VARCHAR(50), edad SMALLINT, salario DECIMAL(10, 2), fecha_nacimiento DATE, es_activo BOOLEAN, foto BLOB );

En este ejemplo:

id es un entero que actúa como clave primaria.
nombre es una cadena de caracteres de longitud variable hasta 50 caracteres.
edad es un entero pequeño.
salario es un número decimal con hasta 10 dígitos en total y 2 decimales.
fecha_nacimiento es una fecha.
es_activo es un valor booleano.
foto es un objeto binario grande, útil para almacenar imágenes u otros datos binarios.


CEWAR UNA DB ....

Normalización: Aplica las tres reglas de normalización para evitar redundancias.
Claves: Comprende las primary keys, foreign keys, claves de negocios y subProgadas.
Tipos de datos: Identifica correctamente los tipos de datos para cada atributo.

Sintaxis de creación: Usa CREATE DATABASE nombre_base_de_datos; para la base de datos y CREATE TABLE nombre_tabla (atributos); para las tablas.
Consistencia en nombres: Mantén un formato uniforme (mayúsculas o minúsculas) para nombres de tablas y atributos.

Primary key: Elige una clave única, como un ID autoincremental.
Atributos de negocio: Utiliza claves de negocio para identificación externa.
Tipos de datos: Selecciona tipos adecuados, como INTEGER para IDs y VARCHAR para textos.


Trazabilidad: Incluye fecha_de_carga y fecha_de_modificación para monitorear cambios y soportar decisiones basadas en datos.
Cumplimiento: Asegura que los datos están actualizados y documentados.

Foreign key: Define la relación entre tablas usando FOREIGN KEY apuntando a la primary key de otra tabla.
Ejemplo: Relacionar estudiantes y cursos con una tabla intermedia que contenga las claves foráneas id_estudiante e id_curso.


HISTORIA && EVOLUCION SQL ...

SQL, que significa “Structured Query Language” (Lenguaje de Consulta Estructurado), es un lenguaje de programación utilizado para gestionar y manipular bases de datos relacionales. Es el estándar de facto para interactuar con sistemas de gestión de bases de datos (DBMS) como MySQL, PostgreSQL, Oracle, y SQL Server. Desde su creación, SQL ha sido fundamental en el desarrollo de aplicaciones que requieren almacenamiento y recuperación eficiente de datos.

Orígenes de SQL
El Inicio en IBM
La historia de SQL comienza en la década de 1970 en los laboratorios de IBM. Edgar F. Codd, un científico de la computación británico, propuso el modelo relacional para bases de datos en su documento de 1970 titulado “A Relational Model of Data for Large Shared Data Banks”. Este modelo revolucionó la manera en que los datos podían ser organizados y accedidos.

System R: El Proyecto Pionero
En 1974, el proyecto System R fue iniciado por IBM en San José, California, con el objetivo de crear un prototipo de sistema de base de datos relacional basado en las ideas de Codd. Dos investigadores, Donald D. Chamberlin y Raymond F. Boyce, desarrollaron el lenguaje SEQUEL (Structured English Query Language) para interactuar con System R. SEQUEL, que más tarde se renombró como SQL debido a problemas de marca registrada, fue diseñado para ser un lenguaje de consulta intuitivo y fácil de usar.

Evolución y Estándarización
Comercialización y Adopción
IBM no fue el único en reconocer el potencial de SQL. En 1979, Oracle (entonces Relational Software, Inc.) lanzó su producto comercial de base de datos, Oracle V2, que implementaba SQL. Este fue el primer DBMS comercial que utilizó SQL, marcando el comienzo de una rápida adopción en la industria.

Estándares ANSI e ISO
En 1986, SQL fue adoptado como estándar por la American National Standards Institute (ANSI) y un año después por la Organización Internacional de Normalización (ISO). Esta estandarización fue crucial para garantizar la interoperabilidad entre diferentes sistemas de bases de datos y facilitó la adopción masiva de SQL en diversas aplicaciones.

Versiones y Actualizaciones
A lo largo de los años, SQL ha visto numerosas revisiones y adiciones, reflejando las necesidades cambiantes de la industria de tecnología de la información. Algunas de las versiones importantes incluyen:

SQL-86: La primera versión estándar de SQL.
SQL-89: Incluyó correcciones y pequeñas mejoras al estándar inicial.
SQL-92: Introdujo características importantes como subconsultas, uniones externas y tipos de datos adicionales.
SQL:1999 (SQL3): Agregó soporte para programación orientada a objetos, triggers, y procedimientos almacenados.
SQL:2003: Introdujo XML nativo y mejoras en la gestión de datos.
SQL:2008: Añadió soporte para datos temporales y mejoras en la portabilidad.
SQL:2011: Introdujo soporte para procesamiento de datos en paralelo.
SQL:2016: Incorporó mejoras significativas en la seguridad y gestión de JSON.

Características Clave de SQL.

Lenguaje de Manipulación de Datos (DML)

SQL permite realizar operaciones básicas de manipulación de datos a través de comandos como:

SELECT: Recuperar datos de una base de datos.
INSERT: Insertar nuevos datos en una tabla.
UPDATE: Modificar datos existentes.
DELETE: Eliminar datos de una tabla.

Lenguaje de Definición de Datos (DDL)

SQL también proporciona comandos para definir y modificar la estructura de la base de datos:

CREATE TABLE: Crear una nueva tabla.
ALTER TABLE: Modificar una tabla existente.
DROP TABLE: Eliminar una tabla.
Control de Acceso y Transacciones
Con SQL, los usuarios pueden controlar el acceso a los datos y garantizar la integridad de las transacciones a través de comandos como:

GRANT y REVOKE: Controlar permisos de acceso.
BEGIN TRANSACTION, COMMIT, y ROLLBACK: Gestionar transacciones para asegurar la integridad de los datos.

Los operadores lógicos son palabras clave que permiten combinar condiciones en una consulta para obtener resultados más específicos

AND: Se utiliza para combinar dos o más condiciones y todas deben ser verdaderas para que se cumpla la condición general ejemplo: SELECT * FROM INSTRUCTORS WHERE SALARY > 50000 AND FIRSTNAME LIKE 'J%';

OR: Se usa para combinar dos o más condiciones y al menos una de ellas debe ser verdadera para que se cumpla la condición general ejemplo: SELECT * FROM INSTRUCTORS WHERE SALARY > 50000 OR FIRSTNAME LIKE 'J%';

NOT: Se usa para negar una condición. Cambia una condición verdadera a falsa y viceversa. ejemplo: SELECT * FROM COURSES WHERE NOT COURSENAME = 'Introduction to programming'; esta me va dar el resto de cursos excepto el curso con ese nombre.

IN: se usa para especificar múltiples valores en una condición. Permite verificar si una columna coincide con cualquiera de los valores de una lista especificada. por ejemplo: SELECT * FROM COURSES WHERE DURATIONHOURS IN (40,50); esto me selecciona a todos los cursos con una duracion de 40 o 50 horas. Tambien IN es usado para hacer una subconsulta para obtener resultados más dinámicos y complejos por ejemplo:

SELECT * FROM STUDENTS WHERE STUDENTID IN(SELECT STUDENTID FROM STUDENT_COURSE WHERE COURSEID = 1 ); esta me muestra los estudiantes que hacen el curso con id = 1.

CREATE INDEX
Un índice en SQL es similar a un índice en un libro: ayuda a encontrar información rápidamente sin tener que revisar todas las páginas. Los índices mejoran la velocidad de las consultas sobre una tabla.

CREATE INDEX se utiliza para crear un índice en una tabla.
Los índices pueden ser creados en una o más columnas de una tabla.
Ayudan a acelerar las búsquedas y las consultas de datos.
Ejemplo:

CREATE INDEX idx_employee_name ON employees (name);

En este ejemplo, se crea un índice llamado idx_employee_name en la columna name de la tabla employees. Ahora, las consultas que buscan por el nombre serán más rápidas.

////////////////////////////////////////////////////////////////

TRIGGER
Un disparador (trigger) es un conjunto de instrucciones que se ejecutan automáticamente en respuesta a ciertos eventos en una tabla o vista, como inserciones, actualizaciones o eliminaciones de datos.

Los triggers pueden ejecutarse antes o después de un evento específico (como BEFORE INSERT o AFTER UPDATE).
Son útiles para mantener la integridad de los datos y realizar tareas automáticas.

Las bases de datos distribuidas: es una colección de múltiples bases de datos separadas físicamente que se comunican mediante una red informática.

VENTAJAS:

-desarrollo modular. -incrementa la confiabilidad. -mejora el rendimiento. -mayor disponibilidad. -rapidez de respuesta.

DESVENTAJAS:

-Manejo de seguridad. -complejidad de procesamiento. -Integridad de datos más compleja. -Costo.

TIPOS:

Homogéneas: mismo tipo de BD, manejador y sistema operativo. (aunque esté distribuida). Heterogénea: puede que varíen alguna de los anteriores características. -OS -Sistema de bases de datos. -Modelo de datos.

ARQUITECTURAS: -** cliente- servidor**: donde hay una BD principal y tiene varias BD que sirven como clientes o como esclavas que tratarán de obtener datos de la principal, a la que normalmente se hacen las escrituras.

Par a par (peer 2 peer): donde todos los puntos en la red de bd son iguales y se hablan como iguales sin tener que responder a una sola entidad.
multi manejador de bases de datos.
ESTRATEGIA DE DISEÑO:

top down: es cuando planeas muy bien la BD y la vas configurando de arriba hacia abajo de acuerdo a tus necesidades.
bottom up: ya existe esa BD y tratas de construir encima.
ALMACENAMIENTO DISTRIBUIDO:

-Fragmentación: qué datos van en dónde.

fragmentación horizontal: (sharding) partir la tabla que estás utilizando en diferentes pedazos horizontales.

fragmentación vertical: cuando parto por columnas.

fragmentación mixta: cuando tienes algunas columnas y algunos datos en un lugar y algunas columnas y algunas tuplas en otro lugar.

-Replicación: tienes los mismos datos en todas ala BBDD no importa donde estén.

-replicación completa: cuando toda al BD está en varias versiones a lo largo del globo, toda la información está igualita en todas las instancias de BD. -replicación parcial: cuando algunos datos están replicados y compartidos en varias zonas geográficas -sin replicación: no estás replicando nada de los datos, cada uno está completamente separa y no tienen que estarse hablando para sincronizar datos entre ellas.

DISTRIBUCIÓN DE DATOS:

-Distribución: cómo va a pasar la data entre una BD y otra. Tiene que ver mucho con networking, tiempos, latencia, etc. Pueden ser:

Centralizada: cuando la distribuyes des un punto central a todas las demás Particionada: está partida en cada una de las diversas zonas geográficas y se comparten información entre ellas. Replicada: tener la misma información en todas y entre ellas se hablan para siempre tener la misma versión.

WINDOWS FUNCTIONS  \n

Realizan cálculos que relacionan una tupla con el resto dentro de un mismo scope o partición.

Evita el uso del self joins
Reduce la complejidad alrededor de la analítica, agregaciones y cálculos
Luego de una agregación, la función OVER dicta el scope de la window function, al realizar un PARTITION BY campo
Si no se especifica un PARTITION BY, la funcion OVER() por default tomará toda la tabla
También se puede usar ORDER BY campo, esto agrega un campo de granularidad al cálculo, a la vez que agrupa todos los valores iguales dentro de la partición, que ahora se encuentran ordenados

SELECT *
SUM(colegiatura) OVER (PARTITION BY carrera_id ORDER BY colegiatura)
FROM platzi.alumnos;

Podemos usar funciones de RANK()
Las Window Function se procesan casi al final de todas las operaciones, por eso para usar estas WF como un campo en WHERE, debemos hacer un subquery.

SELECT *
FROM (
SELECT *,
RANK() OVER (PARTITION BY carrera_id ORDER BY colegiatura DESC) AS brand_rank
FROM platzi.alumnos
) AS ranked_colegiaturas_por_carrera
WHERE brand_rank < 3
ORDER BY brand_rank;

Las funciones de ventana (window functions) son un grupo de funciones en SQL que permiten realizar cálculos en conjuntos de datos ordenados. Las funciones de ventana operan en un conjunto de filas denominadas ventana, que se especifica mediante una cláusula OVER.

Las funciones de ventana se utilizan para realizar una variedad de cálculos, incluyendo:

Cálculos de agregación: SUM(), COUNT(), AVG(), MIN(), MAX()
Cálculos de ranking: RANK(), DENSE_RANK(), ROW_NUMBER(), NTILE()
Cálculos de desplazamiento: LAG(), LEAD(), FIRST_VALUE(), LAST_VALUE()
Las funciones de ventana se utilizan comúnmente en análisis de datos para calcular métricas como:

Media móvil: La media móvil de un conjunto de datos es el promedio de los valores de datos en una ventana.
Tasa de crecimiento: La tasa de crecimiento de un conjunto de datos es el porcentaje de cambio en el valor de los datos entre dos puntos en el tiempo.
N principales: Las N principales filas de un conjunto de datos son las filas con los valores más altos o más bajos.
Percentiles: Los percentiles de un conjunto de datos son los valores que dividen el conjunto de datos en partes iguales.

++Particiones y Agregaciones++

ROW_NUMBER(): nos da el numero de fila, se mantiene ordenado por más que establezcamos otro criterio de ordenamiento en donde el ID se desordene
OVER(PARTITION BY campo ORDER BY campo2): particiona según campo y campo2 ordenando por campo 2 y agrupando valores de resultados según esta partición
FIRST_VALUE(campo): trae el primer valor de una serie de datos
LAST_VALUE(campo): trae el último valor de una serie de datos
NTH_VALUE(campo, row_num): trae el enésimo valor de una serie de datos
RANK(): rankea valores según la partition y order by si cabe
DENSE_RANK(): es como el rank, pero si existen varios valores empatados, en lugar de saltar (ej: 1,1,1,4,4,6) mantiene el orden (ej:1,1,1,2,2,3)
PERCENT_RANK(): Rankea según el porcentaje al que pertenece el valor, a través de la siguiente fórmula: ( RANK() - 1 ) / ( total de filas - 1)







